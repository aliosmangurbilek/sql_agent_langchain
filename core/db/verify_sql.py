from __future__ import annotations

"""core.db.verify_sql
-------------------------------------------------
A *minimal yet extensible* guard‑rail layer that validates, rewrites and, if
necessary, blocks SQL generated by the LLM before it reaches the database.

Features
~~~~~~~~
*   **Read‑only enforcement** – denies any statement that is not purely
    `SELECT`.
*   **Single‑statement enforcement** – blocks attempts to chain statements with
    semicolons.
*   **Automatic LIMIT** – appends `LIMIT 1000` if the query has none (configurable).
*   **Cost guard (optional)** – if a SQLAlchemy *Engine* is provided we run
    `EXPLAIN` and reject queries whose total cost exceeds a configurable
    threshold (defaults to *1,000,000*).

Usage
~~~~~
```python
from sqlalchemy import create_engine
from core.db.verify_sql import verify_sql

engine = create_engine("postgresql+psycopg://…")

safe_sql = verify_sql(sql, engine=engine)  # may raise SQLValidationError
```
"""

from typing import Optional
import re
import sqlalchemy as sa

__all__ = [
    "SQLValidationError",
    "UnsafeSQLError",
    "MultipleStatementsError",
    "HighCostSQLError",
    "verify_sql",
]

# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------

class SQLValidationError(RuntimeError):
    """Base class for *all* validation failures."""

class UnsafeSQLError(SQLValidationError):
    """Statement contains a mutating operation (INSERT/UPDATE/DELETE/DDL)."""

class MultipleStatementsError(SQLValidationError):
    """More than one statement detected (e.g. a semicolon chain)."""

class HighCostSQLError(SQLValidationError):
    """`EXPLAIN` cost estimate exceeds the configured threshold."""

# ---------------------------------------------------------------------------
# Validators
# ---------------------------------------------------------------------------

_MUTATION_REGEX = re.compile(r"\b(INSERT|UPDATE|DELETE|MERGE|DROP|ALTER|TRUNCATE|CREATE)\b", re.I)
_SELECT_REGEX   = re.compile(r"\b(SELECT|WITH|EXPLAIN)\b", re.I)  # Allow WITH and EXPLAIN statements
_LIMIT_REGEX    = re.compile(r"\bLIMIT\b", re.I)

_DEFAULT_LIMIT  = 1000
_DEFAULT_MAX_COST = 1_000_000  # arbitrary sane default for Postgres cost units


def _check_single_statement(raw_sql: str) -> None:
    # Simple heuristic: second semicolon means more than one statement.
    if raw_sql.count(";") > 0 and not raw_sql.strip().endswith(";"):
        raise MultipleStatementsError("Only one SQL statement is allowed.")


def _check_read_only(raw_sql: str) -> None:
    # Check for dangerous mutations
    if _MUTATION_REGEX.search(raw_sql):
        raise UnsafeSQLError("Only read‑only (SELECT) queries are permitted.")
    
    # Allow SELECT, WITH (CTE), and EXPLAIN statements
    sql_upper = raw_sql.upper().strip()
    
    # Check if it's a read-only statement
    if not (_SELECT_REGEX.search(raw_sql) or 
            sql_upper.startswith("WITH ") or 
            sql_upper.startswith("EXPLAIN")):
        
        # Check if it's a schema introspection query (these are safe)
        if _is_schema_query(raw_sql):
            return  # Allow schema queries
            
        raise UnsafeSQLError("Query does not appear to be a read-only statement.")


def _is_schema_query(raw_sql: str) -> bool:
    """Check if the query is a safe schema introspection query."""
    sql_upper = raw_sql.upper().strip()
    
    # Allow queries that select from system tables/views
    schema_patterns = [
        "INFORMATION_SCHEMA.",
        "PG_CATALOG.",
        "PG_CLASS",
        "PG_ATTRIBUTE", 
        "PG_NAMESPACE",
        "PG_TYPE",
        "PG_CONSTRAINT",
        "PG_INDEX"
    ]
    
    # Only allow if it contains SELECT and references schema tables
    has_select = _SELECT_REGEX.search(raw_sql)
    has_schema_ref = any(pattern in sql_upper for pattern in schema_patterns)
    
    return has_select and has_schema_ref


def _maybe_append_limit(raw_sql: str, limit: int) -> str:
    # Add a LIMIT if none exists (simple regex, not full parser for perf).
    # Skip LIMIT addition for EXPLAIN queries
    sql_upper = raw_sql.upper().strip()
    if _LIMIT_REGEX.search(raw_sql) or sql_upper.startswith("EXPLAIN"):
        return raw_sql
    return f"{raw_sql.rstrip().rstrip(';')} LIMIT {limit}"


def _check_cost(sql: str, engine: sa.Engine, max_cost: int) -> None:
    explain_sql = f"EXPLAIN {sql}"
    with engine.connect() as conn:
        rows = conn.execute(sa.text(explain_sql)).fetchall()
    # PostgreSQL returns rows like: "Seq Scan on …  (cost=0.00..4319.20 rows=…)".
    costs = []
    for row in rows:  # row is tuple(str) for default driver
        text_line = row[0]
        match = re.search(r"cost=([0-9.]+)\.\.([0-9.]+)", text_line)
        if match:
            costs.append(float(match.group(2)))  # upper bound
    if costs and max(costs) > max_cost:
        raise HighCostSQLError(
            f"EXPLAIN estimated cost {max(costs):,.0f} exceeds {max_cost:,}."  # noqa: E501
        )

# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def verify_sql(
    raw_sql: str,
    *,
    engine: Optional[sa.Engine] = None,
    auto_limit: bool = True,
    limit: int = _DEFAULT_LIMIT,
    cost_guard: bool = True,
    max_cost: int = _DEFAULT_MAX_COST,
) -> str:
    """Validate **and optionally rewrite** *raw_sql*.

    Parameters
    ----------
    raw_sql
        The incoming SQL string (potentially produced by an LLM).
    engine
        Optional SQLAlchemy engine. Only required if *cost_guard* is enabled.
    auto_limit
        When *True* and query lacks a `LIMIT`, we append one.
    limit
        Numerical value to use with *auto_limit*.
    cost_guard
        Run an `EXPLAIN` and block queries whose cost is too high.
    max_cost
        Maximum allowed cost when *cost_guard* is enabled.

    Returns
    -------
    str
        The *possibly modified* SQL string (e.g. LIMIT appended).
    """
    sql = raw_sql.strip()

    # 1️⃣ structural checks
    _check_single_statement(sql)
    _check_read_only(sql)

    # 2️⃣ optional rewrite
    if auto_limit:
        sql = _maybe_append_limit(sql, limit)

    # 3️⃣ optional cost guard
    if cost_guard:
        if engine is None:
            raise SQLValidationError("Engine required for cost guard but not provided.")
        _check_cost(sql, engine, max_cost)

    return sql
